/**
 * Vulnerability service for Container Analysis API integration.
 * @module services/vulnerability
 */

import type { ArtifactRegistryClient } from '../client/client.js';
import type {
  ImageReference,
} from '../types/common.js';
import {
  getRegistryUrl,
  getFullImageName,
  getReferenceString,
  CONTAINER_ANALYSIS_ENDPOINT,
} from '../types/common.js';
import type {
  Occurrence,
  ListOccurrencesResponse,
  VulnerabilityReport,
  ScanStatus,
  Severity,
} from '../types/vulnerability.js';
import { buildVulnerabilityReport } from '../types/vulnerability.js';
import { ArtifactRegistryError } from '../errors.js';
import { buildUrl, httpRequest } from '../client/http.js';

/**
 * Service for vulnerability scanning and Container Analysis operations.
 */
export class VulnerabilityService {
  private readonly client: ArtifactRegistryClient;

  constructor(client: ArtifactRegistryClient) {
    this.client = client;
  }

  // ============================================================
  // Vulnerability Operations
  // ============================================================

  /**
   * Gets vulnerability occurrences for an image.
   *
   * @param image - Image reference (should use digest for accurate results)
   * @returns Vulnerability report
   */
  async getVulnerabilities(image: ImageReference): Promise<VulnerabilityReport> {
    const occurrences = await this.listOccurrences(image, 'VULNERABILITY');
    return buildVulnerabilityReport(occurrences);
  }

  /**
   * Gets the scan status for an image.
   *
   * @param image - Image reference
   * @returns Scan status
   */
  async getScanStatus(image: ImageReference): Promise<ScanStatus> {
    const occurrences = await this.listOccurrences(image, 'DISCOVERY');

    if (occurrences.length === 0) {
      return { status: 'NOT_SCANNED' };
    }

    const discovery = occurrences[0]!;
    const analysisStatus = discovery.discovery?.analysisStatus;

    switch (analysisStatus) {
      case 'SCANNING':
      case 'PENDING':
        return { status: 'SCANNING' };
      case 'FINISHED_SUCCESS':
        return {
          status: 'COMPLETED',
          timestamp: discovery.updateTime,
        };
      case 'FINISHED_FAILED':
        return {
          status: 'FAILED',
          reason: discovery.discovery?.analysisStatusError?.message || 'Unknown error',
        };
      default:
        return { status: 'NOT_SCANNED' };
    }
  }

  /**
   * Waits for a vulnerability scan to complete.
   *
   * @param image - Image reference
   * @param options - Wait options
   * @returns Vulnerability report when scan completes
   */
  async waitForScan(
    image: ImageReference,
    options?: {
      /** Timeout in milliseconds (default: 5 minutes) */
      timeout?: number;
      /** Poll interval in milliseconds (default: 5 seconds) */
      pollInterval?: number;
    }
  ): Promise<VulnerabilityReport> {
    const timeout = options?.timeout ?? 5 * 60 * 1000;
    const pollInterval = options?.pollInterval ?? 5000;
    const deadline = Date.now() + timeout;

    while (Date.now() < deadline) {
      const status = await this.getScanStatus(image);

      switch (status.status) {
        case 'COMPLETED':
          return this.getVulnerabilities(image);
        case 'FAILED':
          throw ArtifactRegistryError.scanFailed(status.reason);
        case 'NOT_SCANNED':
        case 'SCANNING':
          await this.sleep(pollInterval);
          break;
      }
    }

    throw ArtifactRegistryError.scanTimeout();
  }

  /**
   * Gets a vulnerability summary for the project.
   *
   * @param filter - Optional filter (e.g., severity >= HIGH)
   * @returns Summary of vulnerabilities
   */
  async getProjectSummary(
    filter?: string
  ): Promise<{
    totalCount: number;
    bySeverity: Record<Severity, number>;
  }> {
    const occurrences = await this.listProjectOccurrences('VULNERABILITY', filter);
    const report = buildVulnerabilityReport(occurrences);

    return {
      totalCount: report.totalCount,
      bySeverity: report.severityCounts,
    };
  }

  // ============================================================
  // Occurrence Operations
  // ============================================================

  /**
   * Lists occurrences for an image.
   *
   * @param image - Image reference
   * @param kind - Occurrence kind filter (e.g., "VULNERABILITY", "DISCOVERY")
   * @returns List of occurrences
   */
  async listOccurrences(
    image: ImageReference,
    kind?: string
  ): Promise<Occurrence[]> {
    const resourceUri = this.buildResourceUri(image);
    let filter = `resourceUrl="${resourceUri}"`;

    if (kind) {
      filter += ` AND kind="${kind}"`;
    }

    return this.listProjectOccurrences(undefined, filter);
  }

  /**
   * Lists occurrences for the entire project.
   *
   * @param kind - Occurrence kind filter
   * @param filter - Additional filter string
   * @returns List of occurrences
   */
  async listProjectOccurrences(
    kind?: string,
    filter?: string
  ): Promise<Occurrence[]> {
    const projectId = this.client.getProjectId();
    const occurrences: Occurrence[] = [];
    let pageToken: string | undefined;

    let finalFilter = filter ?? '';
    if (kind && !finalFilter.includes('kind=')) {
      finalFilter = finalFilter
        ? `${finalFilter} AND kind="${kind}"`
        : `kind="${kind}"`;
    }

    do {
      const token = await this.client.getAccessToken();
      const url = buildUrl(
        CONTAINER_ANALYSIS_ENDPOINT,
        `/v1/projects/${projectId}/occurrences`,
        {
          filter: finalFilter || undefined,
          pageSize: 100,
          pageToken,
        }
      );

      const response = await httpRequest<ListOccurrencesResponse>('GET', url, {
        headers: {
          'Authorization': `Bearer ${token}`,
        },
      });

      if (response.data.occurrences) {
        occurrences.push(...response.data.occurrences);
      }
      pageToken = response.data.nextPageToken;
    } while (pageToken);

    return occurrences;
  }

  /**
   * Gets a specific occurrence by name.
   *
   * @param name - Occurrence resource name
   * @returns Occurrence details
   */
  async getOccurrence(name: string): Promise<Occurrence> {
    const token = await this.client.getAccessToken();
    const url = buildUrl(
      CONTAINER_ANALYSIS_ENDPOINT,
      `/v1/${name}`,
      {}
    );

    const response = await httpRequest<Occurrence>('GET', url, {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });

    return response.data;
  }

  // ============================================================
  // Helper Methods
  // ============================================================

  /**
   * Builds the resource URI for an image.
   */
  private buildResourceUri(image: ImageReference): string {
    const registryUrl = getRegistryUrl(image);
    const imageName = getFullImageName(image);
    const reference = getReferenceString(image);

    // For vulnerability scanning, use the registry URL format
    if (image.reference.type === 'digest') {
      return `https://${registryUrl}/${imageName}@${reference}`;
    }

    return `https://${registryUrl}/${imageName}:${reference}`;
  }

  /**
   * Sleep helper for polling.
   */
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
